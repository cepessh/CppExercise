# Лабораторная 4 — подготовка до Этапа 0

Цель — подготовиться к обсуждению архитектуры HamArc: понимать постановку задачи, базовую идею помехоустойчивости и уметь работать с аргументами командной строки и файлами.

---

## 1. Понимание задачи (HamArc)

Вопросы для самопроверки:

- Какие режимы должен поддерживать `hamarc`?  
  (создание, список, извлечение, добавление, удаление, конкатенация — сформулируй сам своими словами)

- В чём смысл фразы «помехоустойчивый архиватор» применительно к этой задаче?  
  Что именно должно уметь:
  - исправляться при повреждениях,
  - и в каких случаях программа должна честно сказать «восстановить невозможно»?

- Какие данные должны храниться в архиве **для каждого файла**, чтобы:
  - его можно было извлечь по имени,
  - узнать его исходный размер,
  - вывести список всех файлов?

- Какие сценарии повреждения архива ты можешь придумать?  
  Как, по-твоему, архиватор должен реагировать в каждом случае?

---

## 2. Идея кода Хэмминга

Рекомендуемый материал:
- Hamming code (EN): https://en.wikipedia.org/wiki/Hamming_code  
- Код Хэмминга (RU): https://ru.wikipedia.org/wiki/Код_Хэмминга

Вопросы для самопроверки:

- Что означает, что код Хэмминга «исправляет одну ошибку на блок»?  
- Чем отличается «обнаружить ошибку» от «исправить ошибку»?  
- Что означает запись Hamming(7,4)?  
  Какую роль играют числа 7 и 4?  
- Зачем вообще добавлять дополнительные (проверочные) биты к данным?  
  Как это помогает бороться с ошибками?

---

## 3. Мини-программа №1: парсер аргументов (`toyarc`)

Задача: написать `toyarc`, который умеет разбирать вызов вида

```bash
./toyarc --create --file=arch.haf a.txt b.bin
````

и выводить разобранную информацию (команда, имя архива, файлы).

Команды и флаги, которые `toyarc` должен уметь разбирать (по условию про аргументы командной строки):

- `-c`, `--create` — создание нового архива;
- `-f`, `--file=ARCHNAME` — имя файла с архивом;
- `-l`, `--list` — вывести список файлов в архиве;
- `-x`, `--extract` — извлечь файлы из архива (если не указано какие, то все файлы);
- `-a`, `--append` — добавить файл в архив;
- `-d`, `--delete` — удалить файл из архива;
- `-A`, `--concatenate` — смерджить два архива;
- **свободные аргументы** (без `-`/`--` в начале) трактуются как имена файлов.

Например, в вызове

```bash
./toyarc --create --file=arch.haf a.txt b.bin
```

флаг `--file=arch.haf` задаёт имя архива, а свободные аргументы `a.txt` и `b.bin` — имена файлов, которые нужно положить в этот архив.

Вопросы для самопроверки:

* Понимаешь ли ты, как из `int argc, char* argv[]` достать:

  * флаг команды (`--create`, `--list`, `--extract` и т.п.),
  * значение из аргумента вида `--file=arch.haf`,
  * список аргументов, которые являются именами файлов?

* Можешь ли ты придумать удобную структуру данных для результата парсинга?
  Например, с полями:

  * тип команды,
  * имя архива,
  * вектор имён файлов.

* Какие части языка/стандартной библиотеки разумно использовать:

  * `std::string` для работы с аргументами,
  * `std::vector` для списка файлов,
  * цикл перебора аргументов `for (int i = 1; i < argc; ++i)`,
  * методы `std::string` (`find`, `substr`, проверка префикса `--file=`),
  * `enum class` для представления команды.

### Примеры запуска и вывода `toyarc`

Точный формат вывода можешь придумать сам; ниже приведён один из возможных вариантов.

```bash
./toyarc --create --file=arch.haf a.txt b.bin
command: create
archive: arch.haf
files:
  - a.txt
  - b.bin
```

Пример с короткими флагами:

```bash
./toyarc -l --file=arch.haf
command: list
archive: arch.haf
files: (none)
```

### Подсказка про короткие флаги (`-c`, `-l`, `-x`)

Подумай:

* Как отличить длинные и короткие флаги:

  * строка начинается с `"--"` → длинный флаг,
  * строка начинается с `"-"` и **не** с `"--"` → короткие флаги.
* Как обработать короткие флаги в одном аргументе:

  * например, `-cl` можно разобрать побайтно:

    * `arg[0] == '-'`,
    * пройти по символам `arg[1], arg[2], ...` и для каждого символа (`'c'`, `'l'`, `'x'` и т.д.) выполнить соответствующее действие (внести команду или поставить флаг).
* Как сделать таблицу соответствия символ → действие:

  * `c` → create
  * `l` → list
  * `x` → extract
    и т.п., возможно через `switch` по `char`.

---

## 4. Мини-программа №2: копирование файла блоками (`copyfile`)

Задача: написать `copyfile`, который вызывается так:

```bash
./copyfile input.bin output.bin
```

и копирует данные из входного файла в выходной **поблочно**, не читая весь файл целиком в память.

Вопросы для самопроверки:

* Понимаешь ли ты, как:

  * открыть файл для чтения и файл для записи в бинарном режиме,
  * проверить, что файлы действительно открылись?

* Понимаешь ли ты, как организовать цикл чтения/записи с фиксированным буфером?
  (читать блоки по N байт и сразу же записывать их в выходной файл)

* Какие части стандартной библиотеки логично использовать:

  * `#include <fstream>` — `std::ifstream`, `std::ofstream`,
  * флаги `std::ios::binary`,
  * `#include <vector>` и `std::vector<char>` как буфер,
  * методы `read`, `write`, `gcount`,
  * типы `std::size_t` / `std::streamsize` для подсчёта количества байт.

* Понимаешь ли ты, почему такой подход масштабируется на большие файлы, а чтение всего файла в один `std::string` — нет?

### Примеры запуска и вывода `copyfile`

Разумный вариант поведения — при успешном копировании печатать, сколько байт было скопировано, а в случае ошибок выводить понятное сообщение об ошибке.

Пример успешного запуска:

```bash
./copyfile input.bin output.bin
copied 4096 bytes
```

Пример с ошибкой (входного файла нет):

```bash
./copyfile missing.bin out.bin
error: cannot open input file 'missing.bin'
```

---

## Подсказка про VS Code и `#include`

Если в VS Code строка с локальным `#include` (например, `#include "copy.hpp"`) подчёркивается красным и пишет, что файл не найден, это, как правило, проблема **только подсветки** (IntelliSense), а не самой сборки.

Что можно сделать:

- Наведи курсор на ошибку и нажми `Quick Fix…` → выбери вариант, который добавляет соответствующую папку (например, `HamArc_HW0/copyfile/include`) в `includePath`.
- Либо вручную добавить путь в `includePath` в настройках расширения C/C++ (`c_cpp_properties.json`).

Важно: даже если подчёркивание остаётся, но `CMakeLists.txt` настроен правильно (папка заголовков добавлена через `target_include_directories`), проект будет собираться через `cmake ..` / `cmake --build` независимо от того, что показывает VS Code.

---

## Как собирать (CMake)

Рекомендуемый вариант — собирать всё из корня репозитория:

```bash
cd CppExercise              # если ещё не там
cmake -S . -B build         # конфигурация
cmake --build build         # сборка всех целей
```

После этого мини-программы будут лежать, например:

- `build/HamArc_HW0/toyarc/toyarc`
- `build/HamArc_HW0/copyfile/copyfile`

Если хочешь собирать только одну мини-программу, можно попросить CMake конкретную цель:

```bash
cmake --build build --target copyfile
cmake --build build --target toyarc
```

Альтернатива: собрать из подпапки (например, только `copyfile`):

```bash
cd HamArc_HW0/copyfile
cmake -S . -B build
cmake --build build
./build/copyfile input.bin output.bin
```
